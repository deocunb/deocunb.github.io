---
layout: post
title: "[TIL 2주차] 정렬 알고리즘"
date: 2024-12-16 00:00:00
categories: [theory]
tags: [theory]
---

### 정렬 1

• **버블 정렬**

• **삽입 정렬**

• **선택 정렬**

주어진 데이터에서 추가적인 데이터를 필요로 하지 않고, 그 내부에서 처리

제자리 = inplace ⇒ 교환 시 2가지 중 하나의 데이터를 잠시 잡고있을 메모리가 필요


### 정렬 2

• **합병 정렬** (트리 형태): n만큼의 메모리가 더 필요

• **힙 정렬** (트리 형태)

• **퀵 정렬**: 일반적으로는 매우 빠르지만, 매번 최소 혹은 최대를 pivot으로  잡으면 워스트 복잡도가 매우 큼 ($n^{2}$) ⇒ 워스트 케이스를 피하기 위한 다양한 pivot 설정 방법이 있음

⇒ pivot을 설정 후, 좌측부터 pivot보다 큰 값을 탐색, 우측부터 pivot보다 작은 값을 탐색 후 두 자리를 바꿔주기 → 반복 → 양쪽에서 출발한 탐색이 서로 만나면 pivot과 바꿔주기 → pivot을 중심으로 좌우로 나뉜 배열에 대해서 각각 위 과정을 다시 반복

• **트리 정렬**: 이진 탐색 트리(BST)를 만들어 정렬하는 방식


### 정렬 3

• **기수 정렬**: 낮은 자리부터 정렬. 기수 테이블을 위한 메모리 필요. 복잡도 = $O(dn)$. d는 최대 자리수. 기수 테이블은 0~9로 이루어진 10자리의 **Queue**들을 필요한만큼 차례로 여러 층 쌓음.

⇒ 1의 자리만 기준으로 0~9의 Queue에 정렬 → 10의 자리만 기준으로 0~9의 Queue에 정렬 → 반복

• **계수 정렬**: 카운트를 세어 정렬하는 방식. 카운팅을 위한 메모리 필요. 복잡도 = $O(n+k)$. k는 데이터 내 최대값. **0부터** 데이터 내 **최대값 k까지**로 이루어진 Array가 카운팅 테이블. 데이터에 값이 있으면 테이블의 해당 요소에 +1. 테이블의 순서대로, 카운팅만큼 나열.

• **쉘 정렬**: 삽입 정렬의 약점 보완. 앞 자리의 모든 데이터들과 비교하지 않고 일정 간격을 두어 비교. 간격은 일반적으로 **배열 길이 / 2**로 설정 → 삽입 정렬 → 간격 1/2로 설정 후 다시 삽입 정렬 → 반복


**정렬 알고리즘 복잡도**

• 데이터가 굉장히 커지면 평균 복잡도가 조금 더 유의미.

• 보조 메모리가 1인 경우는 inplace 제자리 정렬. ⇒ inplace나 일부 constant 메모리 외에 추가적으로 쓰면 안되는 코딩 테스트에는 제자리 정렬을 써야 함.

• 안정성: 같은 값에 대해서 순서 뒤바뀜이 일어나지 않음을 의미
(↔ 순서 뒤바뀜이 발생하면 안정성이 없는 것)
